services:
  dev: &commons
    build:
      context: "."
      target: "${MIX_ENV:-dev}"
      args:
        RELEASE_NAME: "${RELEASE_NAME:-storage}"
    image: "${DOCKER_IMAGE_NAME:-kv-dev}"
    stdin_open: true
    entrypoint: ["/bin/bash", "run.sh", "dev"]
    user: "kv"
    env_file: "${DOCKER_ENV_FILE:-.env}"
    ports:
      - "${DOCKER_HOST_PORT}:4000"
    volumes:
      - ".:/app"
      - "not_used__build:/app/_build/"
      - "not_used_deps:/app/deps/"
      - "not_used_.elixir_ls:/app/.elixir_ls/"
    networks:
      kv-dev:

  # For production build. Use `prod` as host name for single node erlang
  # distribution. E.g. `server1@prod`, `server2@prod` etc.
  prod:
    <<: *commons
    entrypoint: ["/app/bin/run", "start"]
    # Volume mappings is not needed in production in case we want to run
    # production image with docker compose
    volumes:
      - "not_used:/app/"
    networks:
      kv:

volumes:
  not_used__build:
  not_used_deps:
  not_used_.elixir_ls:
  not_used:

networks:
  kv-dev:
  # This defines the docker network used in single node erlang distribution.
  # We can use the service name `prod` as host name.
  kv:
    driver: bridge
    # Required for a stable docker network name for erlang distribution.
    name: kv
